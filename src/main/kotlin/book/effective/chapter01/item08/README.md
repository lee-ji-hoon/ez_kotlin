## 적절하게 null을 처리하라.

### nullable을 처리하는 방법은 보편적으로 3가지가 존재한다.

- `?.`, 스마트 캐스팅, Elvis (?:) 연산자 등을 활용해서 처리한다.
- throw를 던진다.
- 함수 또는 프로퍼티를 아예 리팩토링해서 nullable 타입이 나오지 않게 한다.
  - 이 방법은 애매하다고 생각을 했는데 api 요청 값이 null 이면 기본 값으로 하게 한다던지 하면 가능한 이야기가 될 수 있을거 같다.

> 예시 코드는 SafetyHandleNull.kt 파일에 있다.

### 방어적 프로그래밍

- null 일때 출력하지 않거나 early return 등
- 코드가 프로덕션 환경으로 돌악ㅆ을 때 발생할 수 있는 수많은 것들로부터 프로그램 방어
- 안정성을 높이는 방법을 나타내는 굉장히 포괄적은 용어이다.

> 실제로 회사에서도 내가 StateFlow에서 null 처리를 했을 때 다들 많은 걱정을 했다.    
> 프로덕션 환경에서는 null 값으로 인해서 앱이 터지는 것보다 차라리 기본 값을 넣는 것을 좀 더 지향하는 모습이다.

### 공격적 프로그래밍

- 모든 상황을 안전하게 처리하는 것은 불가능하다.
- 예상하지 못한 상황이 발생했을 때, 문제를 개발자에게 알려서 수정하게 만드는 것이다.
- 이런 것을 assert, require, check가 수행 하고 잇는 것이다.

### not-null assertion(!!) 사용하지 말자.

- !!은 nullable을 처리할 때 발생할 수 있는 문제가 똑같이 발생한다.
- 어떤 대상이 null이 아니라고 생각하고 다루면 NPE가 발생한다.
- null이 나오지 않는다는 것이 거의 확실한 상황에서 쓴다고 적혀져 있다.
  - 하지만 `거의 확실`이라고 적혀져 있다.
  - 나중에 코드가 수정이 되면 해당 값이 null 값이 들어올 수도 있는 것이기 때문에 절대로 해서는 안된다.

### 의미 없는 nullability 피하자.

> 꼭 필요한 경우가 아니면 객체를 nullable 하게 만들지 말자. 정말 귀찮은 일이 많이 생긴다.

- 빈 컬렉션의 경우 null을 리턴하지 말고 emptyList 등 빈 컬렉션을 사용하자.
- nullable enum과 None enum은 완전히 다른 의미이다.
  - null enum은 별도로 처리해야 하지만 None enum은 정의에 없으므로 필요한 경우에 사용하는 쪽에서 추가 하면 된다.
- 어떤 값이 클래스 생성 이후에 확실하게 설정이 된다면 lateinit과 notNull delegate를 사용하자.
  - lateinit의 경우에도 초기화가 돼있지 않다면 예외가 발생한기에 조심해야 한다.
  - notNull delegate의 경우는 많이 사용하지는 않지만 알아두면 나중에 사용할 수 있을거 같다.

```kotlin
private lateinit var doctorName: String
private var doctorId: Int by Delegates.notNull()
```

> delegate 부분은 아이템 21에서 다루게 될테니 우선 이런 것이 있다는 것만 알고가자.
